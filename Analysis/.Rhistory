prior = prior_d,
verbose = F
)
summary(mod_full_breed)
Full_breed$StudyID
length(Full_breed$StudyID)
length(unique(Full_breed$StudyID))
length(unique(Full_breed$Lineage ==))
uniqeu(Full_breed$Lineage)
unique(Full_breed$Lineage)
length(unique(Full_breed$Lineage == "Af_lineage"))
length(unique(Full_breed[Full_breed$Lineage == "Af_lineage", "StudyID"]))
length(unique(Full_breed[Full_breed$Lineage == "A_lineage", "StudyID"]))
length(unique(Full_breed[Full_breed$Lineage == "C_lineage", "StudyID"]))
length(unique(Full_breed[Full_breed$Lineage == "Buck_lineage", "StudyID"]))
length(unique(Full_breed[Full_breed$Lineage == "O_lineage", "StudyID"]))
length(unique(Full_breed[Full_breed$Lineage == "Af_lineage", "StudyID"]))
length((Full_breed[Full_breed$Lineage == "Af_lineage", "StudyID"]))
length((Full_breed[Full_breed$Lineage == "O_lineage", "StudyID"]))
length((Full_breed[Full_breed$Lineage == "C_lineage", "StudyID"]))
length((Full_breed[Full_breed$Lineage == "A_lineage", "StudyID"]))
length(unique(Full_breed[Full_breed$Lineage == "A_lineage", "StudyID"]))
length(unique(Full_breed[Full_breed$Lineage == "Af_lineage", "StudyID"]))
length((Full_breed[Full_breed$Lineage == "Af_lineage", "StudyID"]))
length((Full_breed[Full_breed$Lineage == "Buck_lineage", "StudyID"]))
length(unique(Full_breed[Full_breed$Lineage == "Buck_lineage", "StudyID"]))
length(unique(Full_breed[Full_breed$Lineage == "C_lineage", "StudyID"]))
length((Full_breed[Full_breed$Lineage == "C_lineage", "StudyID"]))
length((Full_breed[Full_breed$Lineage == "O_lineage", "StudyID"]))
length(unique(Full_breed[Full_breed$Lineage == "O_lineage", "StudyID"]))
library(MCMCglmm)
library(hdrcde)
varroa_data <- read.csv("Varroa_treatment_database_2023.10.27.csv",
sep = ",",
header = T)
#we will add a breakdown of synthetic versus non synthetic
chem_split <- as.vector(varroa_data$categoryTreatment)
#We will loop around and replace the the term Chemical with its entry in the
#SubCategory1Treatment variable
for(i in 1:length(chem_split)){
if(chem_split[i] == "Chemical")
{chem_split[i] <- varroa_data$SubCategory1Treatment[i]}
}
#Set it so Synthetic chemicals are the baseline.
chem_split <- factor(chem_split, levels = c("Synthetic",
"Agriculturally_Organic",
"Biological",
"Physical",
"Mixed"))
#Add this new chem_split variable to the data set.
varroa_data <-  data.frame(varroa_data,
chem_split)
#subset to just responses with HoneyBeeIncrease
HoneyBeeIncrease_data <- varroa_data[varroa_data$ResponseVariableCategory ==
"HoneyBeeIncrease",]
#create a column that has unique treatment and response numbers
HoneyBeeIncrease_data$tre_resp <-  paste(HoneyBeeIncrease_data$Treatment_Group,
"_",
HoneyBeeIncrease_data$ResponseNo.,
sep = "")
#empty list to put the final paired rows into
HoneyBeeIncrease_tret_group_temp <- list()
#Data for every study
for (i in 1:length(unique(HoneyBeeIncrease_data$StudyID))){
hbi_stud <- HoneyBeeIncrease_data[HoneyBeeIncrease_data$StudyID ==
unique(HoneyBeeIncrease_data$StudyID)[i],]
#Data for every response target (juvinal. adult etc)
for(z in 1:length(unique(hbi_stud$ResponseVariableTarget))){
hbi_stud_res <- hbi_stud[hbi_stud$ResponseVariableTarget ==
unique(hbi_stud$ResponseVariableTarget)[z],]
for(w in 1:length(unique(hbi_stud_res$tre_resp))){
hbi_tret <- hbi_stud_res[hbi_stud_res$tre_resp ==
unique(hbi_stud_res$tre_resp)[w],]
#HoneyBeeIncrease_tret_group_temp <- vector()
for(t in 1:length(hbi_tret[hbi_tret$Status != "control",1])){
#we default to the first control for now.
hbi_control <- hbi_tret[hbi_tret$Status == "control", ][1,]
#rename the colunm names to _control
colnames(hbi_control) <- paste(names(hbi_control),"_control",sep = "")
#we default to the first control for now.
HoneyBeeIncrease_tret_group_temp[[length(HoneyBeeIncrease_tret_group_temp)+1]]<-
cbind(hbi_tret[hbi_tret$Status != "control",][t,],
hbi_control)
} }
} }
#Now we just
HoneyBeeIncrease_paired <- do.call(rbind.data.frame,
HoneyBeeIncrease_tret_group_temp)
#We can add a row of the log ratio of the response mean value
#(specificResponseMean) divided by the control (specificResponseMean_control)
HoneyBeeIncrease_paired$logratio <-
log(HoneyBeeIncrease_paired$specificResponseMean/
HoneyBeeIncrease_paired$specificResponseMean_control)
#lets recode the NaNs to 0 as they are caused by log(0/0)
#which for our purposes are the same as log(1/1)
HoneyBeeIncrease_paired[ is.nan(HoneyBeeIncrease_paired$logratio),
"logratio"] <- 0
#lets remove any pairs that are infinite.
#These are caused by zeros log(1/0) or log(0/1)
HoneyBeeIncrease_paired_fin <-
HoneyBeeIncrease_paired[!(is.infinite(HoneyBeeIncrease_paired$logratio)),]
#Lets just set Chemical as the baseline
HoneyBeeIncrease_paired_fin$categoryTreatment <-
factor(HoneyBeeIncrease_paired_fin$categoryTreatment,
levels = c("Chemical",
"Physical",
"Biological",
"Mixed")
)
#create a variable that gives a unique identify for nested country continent
HoneyBeeIncrease_paired_fin$Cont_Country <-
paste0(HoneyBeeIncrease_paired_fin$Continent,
HoneyBeeIncrease_paired_fin$Country)
#subset to just responses with HoneyBeeIncrease
HoneyBeeReduction_data <- varroa_data[varroa_data$ResponseVariableCategory ==
"HoneyBeeReduction",]
#create a column that has unique treatment and response numbers
HoneyBeeReduction_data$tre_resp <-  paste(HoneyBeeReduction_data$Treatment_Group,
"_",
HoneyBeeReduction_data$ResponseNo.,
sep = "")
#empty list to put the final paired rows into
HoneyBeeReduction_tret_group_temp <- list()
#Data for every study
for (i in 1:length(unique(HoneyBeeReduction_data$StudyID))){
hbr_stud <- HoneyBeeReduction_data[HoneyBeeReduction_data$StudyID ==
unique(HoneyBeeReduction_data$StudyID)[i],]
#Data for every response target (juvinal. adult etc)
for(z in 1:length(unique(hbr_stud$ResponseVariableTarget))){
hbr_stud_res <- hbr_stud[hbr_stud$ResponseVariableTarget ==
unique(hbr_stud$ResponseVariableTarget)[z],]
for(w in 1:length(unique(hbr_stud_res$tre_resp))){
hbr_tret <- hbr_stud_res[hbr_stud_res$tre_resp==unique(hbr_stud_res$tre_resp)[w],]
for(t in 1:length(hbr_tret[hbr_tret$Status != "control",1])){
#we default to the first control for now.
hbr_control <- hbr_tret[hbr_tret$Status == "control", ][1,]
#rename the colunm names to _control
colnames(hbr_control) <- paste(names(hbr_control),"_control",sep = "")
#we default to the first control for now.
HoneyBeeReduction_tret_group_temp[[length(HoneyBeeReduction_tret_group_temp)+1]]<-
cbind(hbr_tret[hbr_tret$Status != "control",][t,],
hbr_control)
} }
} }
#Now we just
HoneyBeeReduction_paired <- do.call(rbind.data.frame,
HoneyBeeReduction_tret_group_temp)
#We can add a row of the log ratio of the response mean value
#(specificResponseMean) divided by the control (specificResponseMean_control)
HoneyBeeReduction_paired$logratio <-
log(HoneyBeeReduction_paired$specificResponseMean/
HoneyBeeReduction_paired$specificResponseMean_control)
#lets recode the NaNs to 0 as they are caused by log(0/0)
#which for our purposes are the same as log(1/1)
HoneyBeeReduction_paired[ is.nan(HoneyBeeReduction_paired$logratio),
"logratio"] <- 0
#lets remove any pairs that are infinite. #These are caused by zeros log(1/0) or log(0/1)
HoneyBeeReduction_paired_fin <-
HoneyBeeReduction_paired[!(is.infinite(HoneyBeeReduction_paired$logratio)),]
#Lets just set Chemical as the baseline
HoneyBeeReduction_paired_fin$categoryTreatment <-
factor(HoneyBeeReduction_paired_fin$categoryTreatment,
levels = c("Chemical",
"Physical",
"Biological",
"Mixed")
)
#create a variable that gives a unique identify for nested country continent
HoneyBeeReduction_paired_fin$Cont_Country <-
paste0(HoneyBeeReduction_paired_fin$Continent,
HoneyBeeReduction_paired_fin$Country)
#We can also create a version of the data set
#with the log ratio value flipped so that it can be read as a positive value
HoneyBeeReduction_paired_red_fin <- HoneyBeeReduction_paired_fin
HoneyBeeReduction_paired_red_fin$logratio <-
-HoneyBeeReduction_paired_red_fin$logratio
#subset to just responses with VarroaIncrease
VarroaIncrease_data <- varroa_data[varroa_data$ResponseVariableCategory ==
"VarroaIncrease",]
#create a column that has unique treatment and response numbers
VarroaIncrease_data$tre_resp <-  paste(VarroaIncrease_data$Treatment_Group,
"_",
VarroaIncrease_data$ResponseNo.,
sep = "")
#empty list to put the final paired rows into
VarroaIncrease_tret_group_temp <- list()
#Data for every study
for (i in 1:length(unique(VarroaIncrease_data$StudyID))){
vi_stud <- VarroaIncrease_data[VarroaIncrease_data$StudyID ==
unique(VarroaIncrease_data$StudyID)[i],]
#Data for every response target (juvinal. adult etc)
for(z in 1:length(unique(vi_stud$ResponseVariableTarget))){
vi_stud_res <- vi_stud[vi_stud$ResponseVariableTarget ==
unique(vi_stud$ResponseVariableTarget)[z],]
for(w in 1:length(unique(vi_stud_res$tre_resp))){
vi_tret <- vi_stud_res[vi_stud_res$tre_resp == unique(vi_stud_res$tre_resp)[w],]
for(t in 1:length(vi_tret[vi_tret$Status != "control",1])){
#we default to the first control for now.
vi_control <- vi_tret[vi_tret$Status == "control", ][1,]
#rename the colunm names to _control
colnames(vi_control) <- paste(names(vi_control),"_control",sep = "")
#we default to the first control for now.
VarroaIncrease_tret_group_temp[[length(VarroaIncrease_tret_group_temp) + 1]]  <-
cbind(vi_tret[vi_tret$Status != "control",][t,],
vi_control)
} }
} }
#Now we just
VarroaIncrease_paired <- do.call(rbind.data.frame, VarroaIncrease_tret_group_temp)
#We can add a row of the log ratio of the response mean value
#(specificResponseMean) divided by the control (specificResponseMean_control)
VarroaIncrease_paired$logratio <-
log(VarroaIncrease_paired$specificResponseMean/
VarroaIncrease_paired$specificResponseMean_control)
#lets recode the NaNs to 0 as they are caused by log(0/0)
#which for our purposes are the same as log(1/1)
VarroaIncrease_paired[ is.nan(VarroaIncrease_paired$logratio), "logratio"] <- 0
#lets remove any pairs that are infinite.
#These are caused by zeros log(1/0) or log(0/1)
VarroaIncrease_paired_fin <-
VarroaIncrease_paired[!(is.infinite(VarroaIncrease_paired$logratio)),]
#Lets just set Chemical as the baseline
VarroaIncrease_paired_fin$categoryTreatment <-
factor(VarroaIncrease_paired_fin$categoryTreatment,levels = c("Chemical",
"Physical",
"Biological",
"Mixed")
)
#create a variable that gives a unique identify for nested country continent
VarroaIncrease_paired_fin$Cont_Country <-
paste0(VarroaIncrease_paired_fin$Continent,
VarroaIncrease_paired_fin$Country)
#We can also create a version of the dataset
#with the log ratio value flipped so that it can be read as a positive value
VarroaIncrease_paired_red_fin <- VarroaIncrease_paired_fin
VarroaIncrease_paired_red_fin$logratio <- -VarroaIncrease_paired_red_fin$logratio
#subset to just responses with VarroaReduction
VarroaReduction_data <- varroa_data[varroa_data$ResponseVariableCategory ==
"VarroaReduction",]
#create a column that has unique treatment and response numbers
VarroaReduction_data$tre_resp <-  paste(VarroaReduction_data$Treatment_Group,
"_",
VarroaReduction_data$ResponseNo.,
sep = "")
#empty list to put the final paired rows into
VarroaReduction_tret_group_temp <- list()
#Data for every study
for (i in 1:length(unique(VarroaReduction_data$StudyID))){
vr_stud <- VarroaReduction_data[VarroaReduction_data$StudyID ==
unique(VarroaReduction_data$StudyID)[i],]
#Data for every response target (juvinal. adult etc)
for(z in 1:length(unique(vr_stud$ResponseVariableTarget))){
vr_stud_res <- vr_stud[vr_stud$ResponseVariableTarget ==
unique(vr_stud$ResponseVariableTarget)[z],]
for(w in 1:length(unique(vr_stud_res$tre_resp))){
vr_tret <- vr_stud_res[vr_stud_res$tre_resp == unique(vr_stud_res$tre_resp)[w],]
#HoneyBeeIncrease_tret_group_temp <- vector()
for(t in 1:length(vr_tret[vr_tret$Status != "control",1])){
#we default to the first control for now.
vr_control <- vr_tret[vr_tret$Status == "control", ][1,]
#rename the colunm names to _control
colnames(vr_control) <- paste(names(vr_control),"_control",sep = "")
#we default to the first control for now.
VarroaReduction_tret_group_temp[[length(VarroaReduction_tret_group_temp) + 1]]<-
cbind(vr_tret[vr_tret$Status != "control",][t,],
vr_control)
} }
} }
#Now we just
VarroaReduction_paired <- do.call(rbind.data.frame,
VarroaReduction_tret_group_temp)
#We can add a row of the log ratio of the response mean value
#(specificResponseMean) divided by the control (specificResponseMean_control)
VarroaReduction_paired$logratio <-
log(c(VarroaReduction_paired$specificResponseMean)/
c(VarroaReduction_paired$specificResponseMean_control))
#lets recode the NaNs to 0 as they are caused by log(0/0)
#which for our purposes are the same as log(1/1)
VarroaReduction_paired[ is.nan(VarroaReduction_paired$logratio), "logratio"]<- 0
#lets remove any pairs that are infinite.
#These are caused by zeros log(1/0) or log(0/1)
VarroaReduction_paired_fin <-
VarroaReduction_paired[!(is.infinite(VarroaReduction_paired$logratio)),]
#Lets just set Chemical as the baseline
VarroaReduction_paired_fin$categoryTreatment <-
factor(VarroaReduction_paired_fin$categoryTreatment,
levels = c("Chemical",
"Physical",
"Biological",
"Mixed"
)
)
#create a variable that gives a unique identify for nested country continent
VarroaReduction_paired_fin$Cont_Country <-
paste0(VarroaReduction_paired_fin$Continent,
VarroaReduction_paired_fin$Country)
#This just puts all the datasets together.
#We need to rename the median response column to match
names(HoneyBeeIncrease_paired_fin)[names(HoneyBeeIncrease_paired_fin) == "median_hbi_tret_res"] <- "median_res"
names(HoneyBeeReduction_paired_red_fin)[names(HoneyBeeReduction_paired_red_fin) == "median_hbr_tret_res"] <- "median_res"
names(VarroaIncrease_paired_red_fin)[names(VarroaIncrease_paired_red_fin) == "median_vi_tret_res"] <- "median_res"
names(VarroaReduction_paired_fin)[names(VarroaReduction_paired_fin) == "median_vr_tret_res"] <- "median_res"
#Notice HoneyBeeReduction_paired_red_fin and VarroaIncrease_paired_red_fin
#have their signs reversed
Full_comb_data <- rbind(HoneyBeeIncrease_paired_fin,
HoneyBeeReduction_paired_red_fin,
VarroaIncrease_paired_red_fin,
VarroaReduction_paired_fin)
################ Create bee breed catagories ###############
##############################################
#fix typo
Full_comb_data[Full_comb_data$Genetic_group_bees == "Apis_mellifer_carnica",
"Genetic_group_bees"] <- "Apis_mellifera_carnica"
Full_comb_data$Lineage <- Full_comb_data$Genetic_group_bees
#Set out C lineage
Full_comb_data[Full_comb_data$Lineage %in% c("Apis_mellifera_carnica",
"Apis_mellifera_ligustica_Apis_mellifera_carnica_natural_hybrids",
"Apis_mellifera_carnica_Apis_mellifera_ligustica_mixture",
"Apis_mellifera_siciliana",
"Apis_mellifera_ligustica"),
"Lineage"] <- "C_lineage"
#Set out A lineage
Full_comb_data[Full_comb_data$Lineage %in% c("Apis_mellifera_intermissa"),
"Lineage"] <- "A_lineage"
#Set out O lineage
Full_comb_data[Full_comb_data$Lineage %in% c("Apis_mellifera_anatolica",
"Apis_mellifera_meda",
"Apis_mellifera_caucasica",
"Apis_mellifera_syriaca"),
"Lineage"] <- "O_lineage"
#Set out Af lineage
Full_comb_data[Full_comb_data$Lineage %in% c("Apis_mellifera_africanised"),
"Lineage"] <- "Af_lineage"
#Set out buckfast lineage
Full_comb_data[Full_comb_data$Lineage %in% c("Apis_mellifera_buckfast"),
"Lineage"] <- "Buck_lineage"
################ Split the data ###############
##############################################
#just bee data
Full_bees_data <- rbind(HoneyBeeIncrease_paired_fin,
HoneyBeeReduction_paired_red_fin)
#Reset the levels for bees so workers are the baseline
Full_bees_data$ResponseVariableTarget <-
factor(Full_bees_data$ResponseVariableTarget,
levels = c("Honey_bee_worker",
"Honey_bee_colony",
"Honey_bee_juvenile",
"Honey_bee_product",
"Honey_bee_queen"))
#just vorroa data
Full_varroa_data <- rbind(VarroaIncrease_paired_red_fin,
VarroaReduction_paired_fin)
prior_d <-list(R = list(V = 1, nu=0.002),
G = list(G1=list(V = 1, nu=0.002, alpha.mu= 0, alpha.V= 10^3),
G2=list(V = 1, nu=0.002, alpha.mu= 0, alpha.V= 10^3),
G3=list(V = 1, nu=0.002, alpha.mu= 0, alpha.V= 10^3)
))
burnin <- c(10000)
nitt <- c(110000)
thining <- c(50)
Full_breed <-  Full_comb_data[Full_comb_data$Lineage != "Apis_mellifera",]
mod_full_breed <- MCMCglmm(logratio ~ chem_split
+ Context
+ Lineage,
rcov=~units,
random =~StudyID_control
+ Continent
+ Cont_Country,
family ="gaussian",
data = Full_breed,
nitt = nitt,
thin = thining,
burnin = burnin,
prior = prior_d,
verbose = F
)
#second model acts as second chain for convergence
#Add a 3rd later for final check
mod_full_breed2 <- MCMCglmm(logratio ~ chem_split
+ Context
+ Lineage,
rcov=~units,
random =~StudyID_control
+ Continent
+ Cont_Country,
family ="gaussian",
data = Full_breed,
nitt = nitt,
thin = thining,
burnin = burnin,
prior = prior_d,
verbose = F
)
mod_full_breed3 <- MCMCglmm(logratio ~ chem_split
+ Context
+ Lineage,
rcov=~units,
random =~StudyID_control
+ Continent
+ Cont_Country,
family ="gaussian",
data = Full_breed,
nitt = nitt,
thin = thining,
burnin = burnin,
prior = prior_d,
verbose = F
)
summary(mod_full_breed)
summary(mod_full_breed)
unqie(Full_breed$StudyID)
unique(Full_breed$StudyID)
length(Full_breed$StudyID)
length(Full_breed$Lineage)
unique(Full_breed$Lineage)
unique(Full_breed[Full_breed$Lineage == "A_lineage", "StudyID"])
length(unique(Full_breed[Full_breed$Lineage == "A_lineage", "StudyID"]))
length((Full_breed[Full_breed$Lineage == "A_lineage", "StudyID"]))
length((Full_breed[Full_breed$Lineage == "Af_lineage", "StudyID"]))
length((Full_breed[Full_breed$Lineage == "Buck_lineage", "StudyID"]))
length(unique(Full_breed[Full_breed$Lineage == "Buck_lineage", "StudyID"]))
length(unique(Full_breed[Full_breed$Lineage == "C_lineage", "StudyID"]))
length((Full_breed[Full_breed$Lineage == "C_lineage", "StudyID"]))
length((Full_breed[Full_breed$Lineage == "O_lineage", "StudyID"]))
length(unqieu(Full_breed[Full_breed$Lineage == "O_lineage", "StudyID"]))
length(unique(Full_breed[Full_breed$Lineage == "O_lineage", "StudyID"]))
exp(0.25/1)
exp(1.0/25)
exp(1.0/0.25)
exp(-0.25/1)
exp(0.41)
exp(1.6)
exp(1.6-1.04)
exp(1.6-0.83)
exp(1.19-0.51)
exp(-0.51)
exp(-0.4)
exp(-0.41)
exp(-0.41)
exp(1/0.41)
exp(0.41)
exp(0.48)
exp(0.48-0.34)
All_bees_data
life_bees_data <- Full_bees_data[Full_bees_data$ResponseVariableTarget %in%
c("Honey_bee_worker",
"Honey_bee_juvenile"),]
life_bees_data <- life_bees_data[life_bees_data$chem_split %in%
c("Agriculturally_Organic",
"Synthetic",
"Biological"),]
life_bees_data$life_treat <- paste(life_bees_data$chem_split,
life_bees_data$ResponseVariableTarget,
sep = "_")
life_bees_data$life_treat <- factor(life_bees_data$life_treat,
levels = c("Synthetic_Honey_bee_worker",
"Synthetic_Honey_bee_juvenile",
"Agriculturally_Organic_Honey_bee_worker",
"Agriculturally_Organic_Honey_bee_juvenile",
"Biological_Honey_bee_worker",
"Biological_Honey_bee_juvenile"))
mod_bees_life <- MCMCglmm(logratio ~ life_treat + Context,
rcov=~units,
random =~StudyID_control
+ Continent
+ Cont_Country,
family ="gaussian",
data = life_bees_data,
nitt = nitt,
thin = thining,
burnin = burnin,
prior = prior_d,
verbose = FALSE
)
mod_bees_life2 <- MCMCglmm(logratio ~ life_treat + Context,
rcov=~units,
random =~StudyID_control
+ Continent
+ Cont_Country,
family ="gaussian",
data = life_bees_data,
nitt = nitt,
thin = thining,
burnin = burnin,
prior = prior_d,
verbose = FALSE
)
mod_bees_life3 <- MCMCglmm(logratio ~ life_treat + Context,
rcov=~units,
random =~StudyID_control
+ Continent
+ Cont_Country,
family ="gaussian",
data = life_bees_data,
nitt = nitt,
thin = thining,
burnin = burnin,
prior = prior_d,
verbose = FALSE
)
#Check the fixed terms
mod_bees_life_Sol_conv <- gelman.diag(mcmc.list(mod_bees_life$Sol,
mod_bees_life2$Sol,
mod_bees_life3$Sol))
mod_bees_life_Sol_conv
#Check the random terms
mod_bees_life_VCV_conv <- gelman.diag(mcmc.list(mod_bees_life$VCV,
mod_bees_life2$VCV,
mod_bees_life3$VCV))
mod_bees_life_VCV_conv
summary(mod_bees_life)
exp(0.2-41)
